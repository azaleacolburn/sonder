use std::{cell::RefCell, rc::Rc};

use crate::{ast::TokenNode as Node, lexer::CType};

pub type LineNumber = usize;

#[derive(Debug, Clone)]
pub struct VarData {
    // Usage / Block
    pub references: Vec<Rc<RefCell<Reference>>>, // References held to this variable
    pub usages: Vec<Usage>,

    // General Information
    pub var_type: CType,
    pub ptr_to: Vec<Rc<RefCell<Reference>>>, // References held by this variable
    pub rc: bool,
    pub clone: bool, // Cloned value (generated by sonder)
    pub is_mut: bool,

    // Struct handling
    pub instanceof_struct: Option<String>,
    pub fieldof_struct: Option<FieldInfo>,
}

impl VarData {
    pub fn new(
        var_type: CType,
        clone: bool,
        instanceof_struct: Option<String>,
        fieldof_struct: Option<FieldInfo>,
    ) -> Self {
        VarData {
            references: Vec::new(),
            usages: Vec::new(),
            var_type,
            ptr_to: Vec::new(),
            rc: false,
            clone,
            is_mut: false,
            instanceof_struct,
            fieldof_struct,
        }
    }

    /// Returns the outstanding reference held by this variable
    /// TODO Check if the last reference in the list is always the current reference
    pub fn current_reference_held(&self) -> Option<Rc<RefCell<Reference>>> {
        match self.references.last() {
            // Some(reference) if reference.borrow().start > line || reference.borrow().end > line => None,
            Some(reference) => Some(reference.clone()),
            None => None,
        }
    }

    pub fn new_usage(&mut self, line: LineNumber) {
        let usage = Usage::new(line, UsageType::RValue);
        self.usages.push(usage);

        if let Some(reference) = self.current_reference_held() {
            reference.borrow_mut().end = line;
        }
    }

    pub fn is_ptr(&self) -> bool {
        self.ptr_to.len() > 0
    }
}

/// Represents a singlular usage of a variable, not including its reference being taken

#[derive(Debug, Clone)]
pub struct Usage {
    line: LineNumber,
    usage_type: UsageType,
}

#[derive(Debug, Clone)]
pub enum UsageType {
    FunctionArg,
    RValue,
    LValue,
}

impl Usage {
    pub fn new(line: LineNumber, usage_type: UsageType) -> Self {
        Usage { line, usage_type }
    }
}

/// Represents a span where a variable is behind a reference
/// A Reference is extended when the variable holding the reference is used
/// NOTe: Could be extended to Block soon

#[derive(Debug, Clone)]
pub struct Reference {
    reference_type: ReferenceType,
    ref_to: String,
    borrower: String,
    start: LineNumber,
    end: LineNumber,
}

#[derive(Debug, Clone)]
pub enum ReferenceType {
    MutBorrowed,
    ConstBorrowed,
    MutPtr,
    ConstPtr,
}

impl Reference {
    pub fn new(ref_to: impl ToString, borrower: impl ToString, line: LineNumber) -> Self {
        Reference {
            reference_type: ReferenceType::ConstBorrowed,
            ref_to: ref_to.to_string(),
            borrower: borrower.to_string(),
            start: line,
            end: line,
        }
    }

    // Non-inclusive on either end
    pub fn within_current_range(&self, line: usize) -> bool {
        self.start < line && self.end > line
    }

    pub fn set_mut(&mut self) {
        self.reference_type = ReferenceType::MutBorrowed;
    }

    pub fn get_reference_to(&self) -> &str {
        &self.ref_to
    }

    pub fn get_borrower(&self) -> &str {
        &self.borrower
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum PtrType {
    Rc,
    RcRefClone,
    RefCell,
    RawPtrMut,
    RawPtrImut,
    MutRef,
    ImutRef,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct StructData {
    pub field_definitions: Vec<FieldInfo>,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct FieldInfo {
    struct_id: String,
    field_id: String,
}
